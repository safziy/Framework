java原生的阻塞IO模式

传统IO方式（阻塞I/O）在调用InputStream.read()/buffer.readLine()方法时是阻塞的，它会一直等到数据到来或缓冲区已满时或超时时才会返回，并且产生了大量String类型垃圾，尽管可以使用StringBuffer优化；同样，在调用ServerSocket.accept()方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。并且多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。每个线程遇到外部未准备好的时候，都会阻塞掉。阻塞的结果就是会带来大量的进程上下文切换。且大部分进程上下文切换可能是无意义的。比如假设一个线程监听某一个端口，一天只会有几次请求进来，但是该 cpu 不得不为该线程不断做上下文切换尝试，大部分的切换以阻塞告终